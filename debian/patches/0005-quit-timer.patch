From: Aron Xu <aron@debian.org>
Date: Mon, 13 Feb 2012 15:16:04 +0800
Subject: quit timer

---
 nc.1     |  5 +++++
 netcat.c | 35 ++++++++++++++++++++++++++++++++---
 2 files changed, 37 insertions(+), 3 deletions(-)

diff --git a/nc.1 b/nc.1
index 9374dc5..ca355c2 100644
--- a/nc.1
+++ b/nc.1
@@ -40,6 +40,7 @@
 .Op Fl O Ar length
 .Op Fl P Ar proxy_username
 .Op Fl p Ar source_port
+.Op Fl q Ar seconds
 .Op Fl s Ar source
 .Op Fl T Ar toskeyword
 .Op Fl V Ar rtable
@@ -171,6 +172,10 @@ Proxy authentication is only supported for HTTP CONNECT proxies at present.
 Specifies the source port
 .Nm
 should use, subject to privilege restrictions and availability.
+.It Fl q Ar seconds
+after EOF on stdin, wait the specified number of seconds and then quit. If
+.Ar seconds
+is negative, wait forever.
 .It Fl r
 Specifies that source and/or destination ports should be chosen randomly
 instead of sequentially within a range or in the order that the system
diff --git a/netcat.c b/netcat.c
index 7dadac4..1d20b8e 100644
--- a/netcat.c
+++ b/netcat.c
@@ -86,6 +86,7 @@
 #include <errno.h>
 #include <netdb.h>
 #include <poll.h>
+#include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -127,6 +128,7 @@ int	Nflag;					/* shutdown() network socket */
 int	nflag;					/* Don't do name look up */
 char   *Pflag;					/* Proxy username */
 char   *pflag;					/* Localport flag */
+int     qflag = 0;                             /* Quit after some secs */
 int	rflag;					/* Random ports flag */
 char   *sflag;					/* Source Address */
 int	tflag;					/* Telnet Emulation */
@@ -169,6 +171,7 @@ ssize_t fillbuf(int, unsigned char *, size_t *);
 
 static int connect_with_timeout(int fd, const struct sockaddr *sa,
         socklen_t salen, int ctimeout);
+static void quit();
 
 int
 main(int argc, char *argv[])
@@ -192,7 +195,7 @@ main(int argc, char *argv[])
 	sv = NULL;
 
 	while ((ch = getopt(argc, argv,
-	    "46CDdFhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z")) != -1) {
+	    "46CDdFhI:i:klNnO:P:p:q:rSs:tT:UuV:vw:X:x:z")) != -1) {
 		switch (ch) {
 		case '4':
 			family = AF_INET;
@@ -245,6 +248,11 @@ main(int argc, char *argv[])
 		case 'p':
 			pflag = optarg;
 			break;
+                case 'q':
+			qflag = strtonum(optarg, INT_MIN, INT_MAX, &errstr);
+			if (errstr)
+				errx(1, "quit timer %s: %s", errstr, optarg);
+			break;
 		case 'r':
 			rflag = 1;
 			break;
@@ -1045,10 +1053,20 @@ readwrite(int net_fd)
 			if (pfd[POLL_NETOUT].fd != -1 && Nflag)
 				shutdown(pfd[POLL_NETOUT].fd, SHUT_WR);
 			pfd[POLL_NETOUT].fd = -1;
+			goto exit_on_eof;
 		}
 		/* net in gone and queue empty? */
 		if (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {
 			pfd[POLL_STDOUT].fd = -1;
+			exit_on_eof:
+				/* if the user asked to exit on EOF, do it */
+				if (qflag == 0)
+					return;
+				/* if user asked to die after a while, arrange for it */
+				else if (qflag > 0) {
+					signal(SIGALRM, quit);
+					alarm(qflag);
+				}
 		}
 	}
 }
@@ -1434,6 +1452,7 @@ help(void)
 	\t-O length	TCP send buffer length\n\
 	\t-P proxyuser\tUsername for proxy authentication\n\
 	\t-p port\t	Specify local port for remote connects\n\
+        \t-q secs\t	quit after EOF on stdin and delay of secs\n\
 	\t-r		Randomize remote ports\n\
 	\t-S		Enable the TCP MD5 signature option\n\
 	\t-s addr\t	Local source address\n\
@@ -1456,9 +1475,19 @@ usage(int ret)
 {
 	fprintf(stderr,
 	    "usage: nc [-46CDdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\n"
-	    "\t  [-P proxy_username] [-p source_port] [-s source] [-T toskeyword]\n"
-	    "\t  [-V rtable] [-w timeout] [-X proxy_protocol]\n"
+	    "\t  [-P proxy_username] [-p source_port] [-q seconds] [-s source]\n"
+	    "\t  [-T toskeyword] [-V rtable] [-w timeout] [-X proxy_protocol]\n"
 	    "\t  [-x proxy_address[:port]] [destination] [port]\n");
 	if (ret)
 		exit(1);
 }
+
+/*
+ * quit()
+ * handler for a "-q" timeout (exit 0 instead of 1)
+ */
+static void quit()
+{
+        /* XXX: should explicitly close fds here */
+        exit(0);
+}
-- 
